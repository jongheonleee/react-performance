s### 250219 알게된 내용 기록

#### 1. React.memo를 활용한 성능 개선
> - 리액트 구동 원리
>   - 리액트는 먼저 컴포넌트를 렌더링함.
>   - 이전에 렌더링된 결과와 비교하여 DOM을 업데이트할지 결정함
>   - 해당 과정에서 만약 컴포넌트가 React.memo()로 둘러 쌓여 있다면, 리액트 컴포넌트를 렌더링하고 메모이징함
>   - 그리고 다름 렌더링이 일어날 때 렌더링하는 컴포넌트의 props가 같다면 리액트는 메모이징된 내용을 제시함
> - <strong>즉, React.memo는 해당 컴포넌트의 props를 메모이제이션하여 캐시 효과를 기대하여 불필요한 리렌더링을 방지함</strong>

<br>

#### 2. React.memo가 props를 비교하는 방법
> - React.memo가 props 혹은 props의 객체를 비교할 때는 '얕은 비교'를 함 
> - 하지만, 이 부분을 커스텀해서 '깊은 비교'를 하게 만들 수 있음

<br>

#### 3. React.memo 사용을 지양해야 하는 경우
> - 렌더링될 때 props가 변경되는 경우가 대부분일 때, React.memo 사용을 지양해야함
>   - React.memo로 래핑할지라도 React는 2가지 작업을 리렌더링할 때마다 수행함
>       - (1) 이전 props와 다음 props의 동등 비교(비교함수 호출)
>       - (2) 비교함수는 거의 false를 반환할 것이기에, 리액트는 이전 렌더링 내용과 다음 렌더링 내용을 비교함
> - <strong>결국, 캐시 히트가 발생활 확률이 적은 상황에서는 사용하면 안됨</strong>

<br>

#### 4. 리액트가 리렌더링되는 경우
> - (1) state 변경이 있을 때
> - (2) 부모 컴포넌트가 렌더링될 때
> - (3) 새로운 props가 들어올 때 
> - (4) shouldComponentUpdate에서 true가 반환될 때
> - (5) forceUpdate가 실행될 때 

<br>

#### 5. useCallback()을 이용한 함수 최적화 
> - 리렌더링시에 함수가 재생성됨. 이는 비효율적임
>   - 원래 컴포넌트가 렌더링될 때, 그 안에 있는 함수도 다시 생성함
>   - 하지만, 똑같은 함수를 컴포넌트가 리렌더링된다고 해서 계속 만드는 것은 비효율적임
>   - 그리고 이렇게 컴포넌트가 리렌더링될 때마다 함수를 재생성한다면, 이 함수를 전달받는 자식 컴포넌트도 리렌더링이 발생함
> - <strong>useCallback()은 메모이제이션된 함수를 변환하는 함수</strong>
> - useCallback으로 인해서 의존성 배열에 추가해준 state 혹은 props가 변하지 않는다면, 함수는 재생성하지 않음
> - 새로 생성되지 않기 때문에 메모리에 새로 할당하지 않고 동일한 참조값을 사용함 
> - 의존성 배열에 아무것도 없다면 컴포넌트가 최초 렌더링 시에만 함수가 생성되며 그 이후에는 동일한 참조값을 사용하는 함수가됨 

<br>

#### 6. useMemo()를 이용한 결과값 최적화
> - 특정 함수에 전달한 매개변수의 값이 이전과 동일하다면, 컴포넌트가 리렌더링 되더라도 연산을 다시 수행하지 않고 이전 렌더링 때 저장한 값을 재활용함 
 